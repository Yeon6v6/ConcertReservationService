# 현재 API 분석(ReservationFacade)

## **개요**

ReservationFacade는 하나의 애플리케이션 내에서 콘서트 좌석 예약과 결제 처리 프로세스를 단일 진입점에서 관리

**모놀리식(Monolithic) 아키텍처** 기반으로 운영되며, 모든 예약 및 결제 프로세스가 **하나의 애플리케이션 내부에서 동작**하는 구조

> 이 방식에서는 **하나의 데이터베이스**와 **단일 트랜잭션 범위** 내에서 좌석 예약, 결제, 사용자 정보(잔액) 갱신 등이 진행된다.

* **주요 기능**:
  * **좌석 예약**: 좌석의 예약 가능 여부를 확인한 후 예약 정보를 생성
  * **결제 처리**: 예약 정보를 조회, 결제 진행, 좌석 상태와 예약 상태 업데이트, 그리고 관련 토큰 만료 처리
* **기술적 특징**:
  * **트랜잭션 관리**: 각 메서드는 Spring의 `@Transactional`을 통해 단일 트랜잭션으로 실행되어, 문제가 발생할 경우 전체 작업이 롤백
  * **동시성 제어**: `@RedisLock` 어노테이션을 활용하여 동일 좌석에 대한 동시 접근을 막아 데이터 무결성을 보장

***

## **로직 분석**

### A. **좌석 예약 프로세스** (reserveSeat)

* **동작 흐름**
  1. **좌석 상태 확인**
     * Concert Service의 `reserveSeat`를 호출하여, 지정된 좌석의 예약 가능 여부를 확인
     * 좌석이 이미 예약되어 있으면, `CustomException`과 함께 `SeatErrorCode.SEAT_ALREADY_RESERVED` 예외를 발생시켜 예약 프로세스를 중단
  2. **예약 정보 생성**
     * 예약이 가능하면 Reservation Service의 `createReservation`을 호출하여 예약 데이터를 생성 후 반환
* **특징**
  * 전체 로직이 하나의 트랜잭션으로 처리되며, Redis 기반 락으로 동일 좌석에 대한 동시 요청을 제어함
    * @RedisLock(prefix = "seat:", key = "#reservationCmd.seatId")

### B. **결제 처리 프로세스** (payReservation)

* **동작 흐름**
  1. **예약 조회 및 검증**
     * **예약 정보 조회**
       * `reservationService.findById(paymentCmd.reservationId())`를 호출하여 해당 예약 정보를 조회
     * **유효성 체크**
       * 조회된 예약 객체가 없으면 `SeatErrorCode.SEAT_NOT_RESERVED` 오류를 발생
       * 예약 객체의 `validate()` 메서드를 통해 결제 진행 전 금액, 상태 등 비즈니스 조건을 확인
  2. **결제 처리**
     * 예약된 좌석의 가격(seatPrice)을 조회한 후, 아래의 메소드를호출하여 사용자의 결제를 진행
       * `userService.processPayment(paymentCmd.userId(),paymentCmd.paymentAmount())`
     * 해당 호출을 통해 사용자의 결제 처리가 완료되고, 남은 잔액(remainingBalance)이 반환
  3. **좌석 및 예약 상태 업데이트**
     * Concert Service를 호출하여 좌석 상태를 결제 완료 상태로 변경
     * Reservation Service를 통해 예약 상태를 갱신
  4. **토큰 만료 처리**:
     * Token Service를 통해 해당 사용자의 토큰을 조회하고, 만료 처리함
  5. **최종 결과 반환**:
     * PaymentResult 객체에 결제 관련 정보를 담아 반환
* **특징**:
  * 여러 도메인(예약, 결제, 좌석, 사용자, 토큰)이 하나의 트랜잭션 내에서 호출되며, Redis 락으로 동시 결제 요청을 제어

### **트랜잭션 분석**

* **트랜잭션 단위**: `processPayment()`는 `@Transactional`을 통해 **예약 조회 → 잔액 차감 → 결제 내역 저장 → 예약 확정**을 **하나의 트랜잭션 내에서 처리**함.
* **주요 트랜잭션 범위**
  1. **예약 정보 조회** (`ReservationRepository`)
  2. **사용자 잔액 차감** (`UserRepository`)
  3. **결제 정보 저장** (`PaymentRepository`)
  4. **예약 확정 처리** (`ReservationRepository`)
* **트랜잭션 실패 시**: 중간 과정에서 오류 발생 시 **잔액 차감 및 결제 정보 저장이 롤백**

***

## **분산 트랜잭션 처리 방안**

모놀리식 환경에서는 ReservationFacade 내부에서 단일 트랜잭션으로 모든 작업을 처리하지만, \
MSA 환경에서는 각 서비스가 독자적인 데이터베이스를 관리하기 때문에 전체 비즈니스 프로세스의 일관성을 유지하는 것이 가장 큰 이슈이다

### A. **분산 트랜잭션의 한계**

* **로컬 트랜잭션 한계**: 각 서비스의 트랜잭션은 해당 서비스 내에서만 ACID를 보장하므로, 여러 서비스에 걸친 비즈니스 프로세스의 일관성은 보장하기 어려움
* **네트워크 장애**: 서비스 간 통신 실패나 네트워크 장애로 인한 데이터 불일치 문제 발생 가능

### B. **해결 방안**

#### 1. 2PC (Two-Phase Commit)

* **원리**:
  * 중앙 코디네이터가 모든 참여 서비스에 준비(prepare) 요청을 보내고, 모든 서비스가 준비 완료되면 최종 커밋을 수행
  * 하나라도 실패하면 전체 롤백
* **장단점**:
  * **장점**: 분산 환경에서도 원자성을 보장할 수 있음
  * **단점**: 중앙 코디네이터 의존, 블로킹 문제, 응답 지연 등으로 성능 및 확장성에 한계가 있음

#### 2. SAGA 패턴

* **원리**:
  * 전체 비즈니스 프로세스를 여러 개의 짧은 로컬 트랜잭션으로 나눈 후, 각 단계가 성공하면 다음 단계로 진행
  * 만약 한 단계에서 실패하면, 이전 단계의 작업을 취소하는 보상 트랜잭션을 수행하여 전체 프로세스의 일관성을 맞춤
* **구분**:
  * **코레오그래피 기반** : 각 서비스가 이벤트를 발행하고, 다음 서비스가 해당 이벤트에 반응하여 로컬 트랜잭션을 실행
  * **오케스트레이션 기반** : 중앙 오케스트레이터가 각 서비스에 순차적으로 명령을 내려 전체 프로세스를 관리
* **장단점**:
  * **장점**: 중앙 실패 지점이 없고, 각 서비스가 독립적으로 트랜잭션을 관리할 수 있어 확장성과 장애 격리가 용이함
  * **단점**: 최종 일관성(Eventual Consistency) 보장이며, 보상 트랜잭션 설계가 복잡할 수 있음

***

## ReservationFacade 로직을 기반으로 한 MSA 전환 예시

1. **좌석 예약 프로세스 분리**
   * **콘서트 서비스**:
     * 좌석의 예약 가능 여부를 체크하고, 좌석 상태를 “임시 예약” 상태로 변경
     * 결과를 이벤트(예: 좌석 예약 완료 이벤트)로 발행
   * **예약 서비스**:
     * 이벤트를 수신하여 예약 정보를 생성하고, 예약 상태를 “예약 대기” 또는 “예약 확정”으로 관리
2. **결제 처리 프로세스 분리**
   * **결제 서비스**:
     * 결제 요청을 받아 결제 이력을 생성하고, 결제 결과를 이벤트로 발행
   * **사용자 서비스**:
     * 결제 이벤트를 수신하여 사용자 잔액을 차감하고, 결제 후 잔액 정보를 업데이트
   * **콘서트/예약 서비스**:
     * 결제 성공 이벤트에 따라 좌석 및 예약 상태를 “결제 완료”로 업데이트
   * **토큰 서비스**:
     * 결제 처리 완료 후, 관련 사용자 토큰을 조회 및 만료 처리 (이벤트 또는 별도 비동기 호출)
3. **트랜잭션 처리**
   * 각 서비스는 자체 로컬 트랜잭션을 사용하여 데이터 무결성을 유지
   * 전체 비즈니스 프로세스(예: 좌석 예약부터 결제 완료까지)는 SAGA 패턴을 도입하여 각 서비스의 로컬 트랜잭션을 순차적으로 실행하고, 실패 시 보상 트랜잭션으로 복구하는 방식으로 관리

